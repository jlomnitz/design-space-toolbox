<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Design Space Toolbox: DSVariable.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>DSVariable.c File Reference</h1>
<p>Implementation file with functions for dealing with variables.  
<a href="#_details">More...</a></p>
<code>#include &lt;stdbool.h&gt;</code><br/>
<code>#include &lt;string.h&gt;</code><br/>
<code>#include &lt;math.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="_d_s_memory_manager_8h_source.html">DSMemoryManager.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="_d_s_errors_8h_source.html">DSErrors.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="_d_s_variable_8h_source.html">DSVariable.h</a>&quot;</code><br/>
<div class="dynheader">
Include dependency graph for DSVariable.c:</div>
<div class="dynsection">
<div class="center"><img src="_d_s_variable_8c__incl.png" border="0" usemap="#_d_s_variable_8c_map" alt=""/></div>
<map name="_d_s_variable_8c_map" id="_d_s_variable_8c">
<area shape="rect" href="_d_s_memory_manager_8h.html" title="Header file with functions for secure memory allocation." alt="" coords="229,82,424,109" /><area shape="rect" href="_d_s_errors_8h.html" title="Header file with functions for error and exception handling." alt="" coords="354,157,464,184" /><area shape="rect" href="_d_s_variable_8h.html" title="Header file with functions for dealing with variables." alt="" coords="497,157,622,184" /><area shape="rect" href="_d_s_types_8h.html" title="Header file with definitions for data types." alt="" coords="229,306,338,333" /><area shape="rect" href="_d_s_i_o_8h.html" title="Header file with standard input and output functions." alt="" coords="314,232,389,258" /></map>
</div>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_d_s_variable.html">DSVariable</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_d_s_variable_8c.html#a6f0ce189a8dc8ce46fad1d7a9b34d31f">DSVariableAlloc</a> (const char *name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new <a class="el" href="struct_d_s_variable.html" title="Data type that is used to store errors.">DSVariable</a> with INFINITY as a default value.  <a href="#a6f0ce189a8dc8ce46fad1d7a9b34d31f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac33e4c3da62459d2e356dd6456fca463"></a><!-- doxytag: member="DSVariable.c::DSNewVariable" ref="ac33e4c3da62459d2e356dd6456fca463" args="(const char *name)" -->
<a class="el" href="struct_d_s_variable.html">DSVariable</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>DSNewVariable</b> (const char *name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_d_s_variable_8c.html#aac8fadf2969493124be37a1076a2b885">DSVariableFree</a> (<a class="el" href="struct_d_s_variable.html">DSVariable</a> *var)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function frees allocated memory of a <a class="el" href="struct_d_s_variable.html" title="Data type that is used to store errors.">DSVariable</a>.  <a href="#aac8fadf2969493124be37a1076a2b885"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_d_s_variable.html">DSVariable</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_d_s_variable_8c.html#a1a5da69573335a86dea1e4a8a6770ea3">DSVariableRetain</a> (<a class="el" href="struct_d_s_variable.html">DSVariable</a> *aVariable)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function to increase variable retain count by one.  <a href="#a1a5da69573335a86dea1e4a8a6770ea3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_d_s_variable_8c.html#a4d83eec85c4d9340593a359fd1d5e506">DSVariableRelease</a> (<a class="el" href="struct_d_s_variable.html">DSVariable</a> *aVariable)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function to decrease variable retain count by one.  <a href="#a4d83eec85c4d9340593a359fd1d5e506"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__var_dictionary.html">DSVariablePool</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_d_s_variable_8c.html#a4882cda43ad2d33bcafded6ed80e1fa6">DSVariablePoolAddVariableWithName</a> (const char *name, <a class="el" href="struct__var_dictionary.html">DSVariablePool</a> *root)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a <a class="el" href="struct_d_s_variable.html" title="Data type that is used to store errors.">DSVariable</a> to the dictionary.  <a href="#a4882cda43ad2d33bcafded6ed80e1fa6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__var_dictionary.html">DSVariablePool</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_d_s_variable_8c.html#aae1be18474aa9db03cb72912fd19234c">DSVariablePoolAddVariable</a> (<a class="el" href="struct_d_s_variable.html">DSVariable</a> *newVar, <a class="el" href="struct__var_dictionary.html">DSVariablePool</a> *root)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a <a class="el" href="struct_d_s_variable.html" title="Data type that is used to store errors.">DSVariable</a> to the dictionary.  <a href="#aae1be18474aa9db03cb72912fd19234c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_d_s_variable.html">DSVariable</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_d_s_variable_8c.html#ae8f75eb27aa14dda00f3251485d675ff">DSVariablePoolVariableWithName</a> (const char *name, <a class="el" href="struct__var_dictionary.html">DSVariablePool</a> *root)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the variable in the dictionary with a matching name.  <a href="#ae8f75eb27aa14dda00f3251485d675ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c5942f23ebe838b353427df52522b2e"></a><!-- doxytag: member="DSVariable.c::DSVariableWithName" ref="a7c5942f23ebe838b353427df52522b2e" args="(const char *name, DSVariablePool *root)" -->
<a class="el" href="struct_d_s_variable.html">DSVariable</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>DSVariableWithName</b> (const char *name, <a class="el" href="struct__var_dictionary.html">DSVariablePool</a> *root)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_d_s_variable_8c.html#aaed3132c306ffc004da9f391bbd1763c">DSVariablePoolFree</a> (<a class="el" href="struct__var_dictionary.html">DSVariablePool</a> *root)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function to remove all nodes in the dictionary.  <a href="#aaed3132c306ffc004da9f391bbd1763c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_d_s_variable_8c.html#acbb9a673f3f91834137f2bde14911f8d">printVarDictionary</a> (<a class="el" href="struct__var_dictionary.html">DSVariablePool</a> *root, DSUInteger indent)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prints the VarDictionary.  <a href="#acbb9a673f3f91834137f2bde14911f8d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_d_s_variable_8c.html#aa807b488d1b5c23e628a63e99ef8d0d9">printMembers</a> (<a class="el" href="struct__var_dictionary.html">DSVariablePool</a> *root, char *buffer, int position)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function that prints the members in the dictionary.  <a href="#aa807b488d1b5c23e628a63e99ef8d0d9"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Implementation file with functions for dealing with variables. </p>
<p>Copyright (C) 2011 Jason Lomnitz.<br/>
<br/>
</p>
<p>This file is part of the Design Space Toolbox V2 (C Library).</p>
<p>The Design Space Toolbox V2 is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</p>
<p>The Design Space Toolbox V2 is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License along with the Design Space Toolbox. If not, see &lt;<a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>&gt;.</p>
<dl class="author"><dt><b>Author:</b></dt><dd>Jason Lomnitz. </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>2011 </dd></dl>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a6f0ce189a8dc8ce46fad1d7a9b34d31f"></a><!-- doxytag: member="DSVariable.c::DSVariableAlloc" ref="a6f0ce189a8dc8ce46fad1d7a9b34d31f" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_d_s_variable.html">DSVariable</a>* DSVariableAlloc </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new <a class="el" href="struct_d_s_variable.html" title="Data type that is used to store errors.">DSVariable</a> with INFINITY as a default value. </p>
<p>This function may be used throughout, in order to create new variables consistently and portably. As variables are allocated individually, it is important to not that they should be released with the accesory method. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>A string with which to identify the <a class="el" href="struct_d_s_variable.html" title="Data type that is used to store errors.">DSVariable</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The pointer to the newly allocated <a class="el" href="struct_d_s_variable.html" title="Data type that is used to store errors.">DSVariable</a>. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="struct_d_s_variable.html" title="Data type that is used to store errors.">DSVariable</a> </dd>
<dd>
<a class="el" href="_d_s_variable_8h.html#aac8fadf2969493124be37a1076a2b885" title="Function frees allocated memory of a DSVariable.">DSVariableFree</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aac8fadf2969493124be37a1076a2b885"></a><!-- doxytag: member="DSVariable.c::DSVariableFree" ref="aac8fadf2969493124be37a1076a2b885" args="(DSVariable *var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DSVariableFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_d_s_variable.html">DSVariable</a> *&nbsp;</td>
          <td class="paramname"> <em>var</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function frees allocated memory of a <a class="el" href="struct_d_s_variable.html" title="Data type that is used to store errors.">DSVariable</a>. </p>
<p>This function should be used for each newDSVariable that is called. The internal structure is subject to changes in consequent versions and therefore freeing memory of DSVariables should be strictly through this function. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The pointer to the variable to free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aae1be18474aa9db03cb72912fd19234c"></a><!-- doxytag: member="DSVariable.c::DSVariablePoolAddVariable" ref="aae1be18474aa9db03cb72912fd19234c" args="(DSVariable *newVar, DSVariablePool *root)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__var_dictionary.html">DSVariablePool</a>* DSVariablePoolAddVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_d_s_variable.html">DSVariable</a> *&nbsp;</td>
          <td class="paramname"> <em>newVar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__var_dictionary.html">DSVariablePool</a> *&nbsp;</td>
          <td class="paramname"> <em>root</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a <a class="el" href="struct_d_s_variable.html" title="Data type that is used to store errors.">DSVariable</a> to the dictionary. </p>
<p>This is the function to add DSVariables to the dictionary. Since the dictionary works alphabetically, the root of the dictionary changes and is defined by this function, and the root, be it the new one or the old one, is returned. This function is used in creating a new dictionary. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>newVar</em>&nbsp;</td><td>The pointer to the variable which is to be added to the dictionary. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>root</em>&nbsp;</td><td>The root of the dictionary. THE ROOT MAY BE REASSIGNED. If null, creates a new dictionary. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The root of the dictionary, which is likely to change. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="struct__var_dictionary.html" title="Internal dictionary structure.">_varDictionary</a> </dd>
<dd>
DSVariableWithName </dd>
<dd>
_addNewBranch </dd></dl>

</div>
</div>
<a class="anchor" id="a4882cda43ad2d33bcafded6ed80e1fa6"></a><!-- doxytag: member="DSVariable.c::DSVariablePoolAddVariableWithName" ref="a4882cda43ad2d33bcafded6ed80e1fa6" args="(const char *name, DSVariablePool *root)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__var_dictionary.html">DSVariablePool</a>* DSVariablePoolAddVariableWithName </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__var_dictionary.html">DSVariablePool</a> *&nbsp;</td>
          <td class="paramname"> <em>root</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a <a class="el" href="struct_d_s_variable.html" title="Data type that is used to store errors.">DSVariable</a> to the dictionary. </p>
<p>This is the function to add DSVariables to the dictionary. Since the dictionary works alphabetically, the root of the dictionary changes and is defined by this function, and the root, be it the new one or the old one, is returned. This function is used in creating a new dictionary. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>newVar</em>&nbsp;</td><td>The pointer to the variable which is to be added to the dictionary. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>root</em>&nbsp;</td><td>The root of the dictionary. THE ROOT MAY BE REASSIGNED. If null, creates a new dictionary. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The root of the dictionary, which is likely to change. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="struct__var_dictionary.html" title="Internal dictionary structure.">_varDictionary</a> </dd>
<dd>
DSVariableWithName </dd>
<dd>
_addNewBranch </dd></dl>

</div>
</div>
<a class="anchor" id="aaed3132c306ffc004da9f391bbd1763c"></a><!-- doxytag: member="DSVariable.c::DSVariablePoolFree" ref="aaed3132c306ffc004da9f391bbd1763c" args="(DSVariablePool *root)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DSVariablePoolFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__var_dictionary.html">DSVariablePool</a> *&nbsp;</td>
          <td class="paramname"> <em>root</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function to remove all nodes in the dictionary. </p>
<p>The function is RECURSIVE and frees all the nodes past the root which is passed. In theory, it could be used to clear a portion of the dictionary, yet doing so would require direct manipulation of the dictionary which is strongly discouraged. The variables themselves are NOT freed, since the dictionary does not allocate them. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>root</em>&nbsp;</td><td>The root of the dictionary which is to be cleared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_d_s_types_8h.html#a67b340fa4a564cc84d27b3647ef1ad75" title="Internal dictionary structure.">DSVariablePool</a> </dd>
<dd>
DSVariableWithName </dd>
<dd>
<a class="el" href="_d_s_variable_8h.html#aae1be18474aa9db03cb72912fd19234c" title="Adds a DSVariable to the dictionary.">DSVariablePoolAddVariable</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae8f75eb27aa14dda00f3251485d675ff"></a><!-- doxytag: member="DSVariable.c::DSVariablePoolVariableWithName" ref="ae8f75eb27aa14dda00f3251485d675ff" args="(const char *name, DSVariablePool *root)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_d_s_variable.html">DSVariable</a>* DSVariablePoolVariableWithName </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__var_dictionary.html">DSVariablePool</a> *&nbsp;</td>
          <td class="paramname"> <em>root</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the variable in the dictionary with a matching name. </p>
<p>This is the function for retriving a <a class="el" href="struct_d_s_variable.html" title="Data type that is used to store errors.">DSVariable</a> from a dictionary. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>A string containing a NULL terminated string containing the name of the desired <a class="el" href="struct_d_s_variable.html" title="Data type that is used to store errors.">DSVariable</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>root</em>&nbsp;</td><td>The root of the dictionary, determined during the adding of variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the variable. If there is no matching variable, NULL is returned. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>_checkNameAtPos </dd>
<dd>
<a class="el" href="_d_s_types_8h.html#a67b340fa4a564cc84d27b3647ef1ad75" title="Internal dictionary structure.">DSVariablePool</a> </dd>
<dd>
<a class="el" href="_d_s_variable_8h.html#aae1be18474aa9db03cb72912fd19234c" title="Adds a DSVariable to the dictionary.">DSVariablePoolAddVariable</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4d83eec85c4d9340593a359fd1d5e506"></a><!-- doxytag: member="DSVariable.c::DSVariableRelease" ref="a4d83eec85c4d9340593a359fd1d5e506" args="(DSVariable *aVariable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DSVariableRelease </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_d_s_variable.html">DSVariable</a> *&nbsp;</td>
          <td class="paramname"> <em>aVariable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function to decrease variable retain count by one. </p>
<p>Fast processing tree is made to decrease its retain count by one, when the retain count hits zero, the function <a class="el" href="_d_s_variable_8c.html#aac8fadf2969493124be37a1076a2b885" title="Function frees allocated memory of a DSVariable.">DSVariableFree()</a> is invoked, freeing the memory space. Fast processing tree does not have an equivalent to autorelease, forcing the developer to use greater care when directly managing memory.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aVariable</em>&nbsp;</td><td>The variable which will have its retain count reduced.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_d_s_variable_8h.html#a1a5da69573335a86dea1e4a8a6770ea3" title="Function to increase variable retain count by one.">DSVariableRetain</a> </dd>
<dd>
<a class="el" href="_d_s_variable_8h.html#aac8fadf2969493124be37a1076a2b885" title="Function frees allocated memory of a DSVariable.">DSVariableFree</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1a5da69573335a86dea1e4a8a6770ea3"></a><!-- doxytag: member="DSVariable.c::DSVariableRetain" ref="a1a5da69573335a86dea1e4a8a6770ea3" args="(DSVariable *aVariable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_d_s_variable.html">DSVariable</a>* DSVariableRetain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_d_s_variable.html">DSVariable</a> *&nbsp;</td>
          <td class="paramname"> <em>aVariable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function to increase variable retain count by one. </p>
<p>Variables utilize a similar memory management system used in Objective-C NSObject subclasses, where objects a retained/released.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aVariable</em>&nbsp;</td><td>The variable which will have its retain count increased.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The same variable which received the retain count increase is returned, for convinience.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_d_s_variable_8h.html#a4d83eec85c4d9340593a359fd1d5e506" title="Function to decrease variable retain count by one.">DSVariableRelease</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa807b488d1b5c23e628a63e99ef8d0d9"></a><!-- doxytag: member="DSVariable.c::printMembers" ref="aa807b488d1b5c23e628a63e99ef8d0d9" args="(DSVariablePool *root, char *buffer, int position)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void printMembers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__var_dictionary.html">DSVariablePool</a> *&nbsp;</td>
          <td class="paramname"> <em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>position</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function that prints the members in the dictionary. </p>
<p>This function recursively checks the dictionary for all names, and prints them out. It requires of a buffer string which is used to store the current characters, since it is a recursive function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>root</em>&nbsp;</td><td>The root of the dictionary, and the current node for consequent calls. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>The string in which to store the characters, function does not check size of buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>position</em>&nbsp;</td><td>Should be 0 when called, increases as it searches the dictionary.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="struct__var_dictionary.html" title="Internal dictionary structure.">_varDictionary</a> </dd>
<dd>
<a class="el" href="_d_s_variable_8h.html#aae1be18474aa9db03cb72912fd19234c" title="Adds a DSVariable to the dictionary.">DSVariablePoolAddVariable</a></dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>Create a wrapper function which creates the buffer, and initiates the position at 0. </dd></dl>

</div>
</div>
<a class="anchor" id="acbb9a673f3f91834137f2bde14911f8d"></a><!-- doxytag: member="DSVariable.c::printVarDictionary" ref="acbb9a673f3f91834137f2bde14911f8d" args="(DSVariablePool *root, DSUInteger indent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void printVarDictionary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__var_dictionary.html">DSVariablePool</a> *&nbsp;</td>
          <td class="paramname"> <em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DSUInteger&nbsp;</td>
          <td class="paramname"> <em>indent</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prints the VarDictionary. </p>
<p>A debugging function which prints the dictionary structure to the stderr file </p>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address style="text-align: right;"><small>Generated on Tue Jul 26 10:31:35 2011 for Design Space Toolbox by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
